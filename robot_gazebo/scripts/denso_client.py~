#! /usr/bin/env python
import sys
from copy import copy
import rospy
import actionlib
import openravepy as orpy
import numpy as np
import time
import random
import criros
from robotiq_control import controller 
from control_msgs.msg import *
from trajectory_msgs.msg import *

class Trajectory(object):
    def __init__(self):
        self._client = actionlib.SimpleActionClient(
            "/denso/trajectory_controller/follow_joint_trajectory",
            FollowJointTrajectoryAction,
        )
        self._goal = FollowJointTrajectoryGoal()
        self._goal_time_tolerance = rospy.Time(0.1)
        self._goal.goal_time_tolerance = self._goal_time_tolerance
        server_up = self._client.wait_for_server()
        if not server_up:
            rospy.logerr("Timed out waiting for Joint Trajectory"
                         " Action Server to connect. Start the action server"
                         " before running example.")
            rospy.signal_shutdown("Timed out waiting for Action Server")
            sys.exit(1)

    def start(self):
        self._goal.trajectory.header.stamp = rospy.Time.now()
        self._client.send_goal(self._goal)

    def stop(self):
        self._client.cancel_goal()

    def wait(self, timeout=15.0):
        self._client.wait_for_result(timeout=rospy.Duration(timeout))

    def result(self):
        return self._client.get_result()

    def clear(self,ros_traj):
        self._goal = FollowJointTrajectoryGoal()
        self._goal.goal_time_tolerance = self._goal_time_tolerance
        self._goal.trajectory = ros_traj
        self._goal.trajectory.joint_names = ['j1', 'j2', 'j3', 'j4', 'j5', 'j6']

def create_box(T, color = [0, 0.6, 0]):
    box = orpy.RaveCreateKinBody(env, '')
    box.SetName('box')
    box.InitFromBoxes(np.array([[0,0,0,0.035,0.03,0.005]]), True)  #actual dimensions of the green boxes: 70mm x 60 mm x 10mm   
    g = box.GetLinks()[0].GetGeometries()[0]
    g.SetAmbientColor(color)
    g.SetDiffuseColor(color)
    box.SetTransform(T)
    env.Add(box,True)
    return box
    
def back_to_idle_position():
	sol  = manip.FindIKSolution(idle,orpy.IkFilterOptions.CheckEnvCollisions)
	sol = np.append(sol,[0])
	print sol
	traj = directplanner(sol)
	return traj
	

def directplanner(sol):
	planner = orpy.RaveCreatePlanner(env,'birrt') # Using bidirectional RRT
	params = orpy.Planner.PlannerParameters()
	params.SetRobotActiveJoints(robot)
	params.SetGoalConfig(sol)
	params.SetExtraParameters('<_postprocessing planner="parabolic_smoother"><_nmaxiterations>40</_nmaxiterations></_postprocessing>')
	planner.InitPlan(robot, params)
	# Plan a trajectory
	traj = orpy.RaveCreateTrajectory(env,'')
	new_traj = planner.PlanPath(traj)
	robot.SetDOFValues(sol)
	return traj
env = orpy.Environment()
env.Load('intro-osr/envs/pick_and_place.xml')
env.SetViewer('qtcoin')
T = np.eye(4)
container_center = np.array([0.4, 0.2, 0.195])
	
# Destination
T[:3, 3] = container_center + np.array([0, -0.4, 0])
destination0 = create_box(T, color = [0, 0, 0.6])
T[:3, 3] = container_center + np.array([0, -0.5, 0])
destination1 = create_box(T, color = [0, 0, 0.6])

# Generate random box positions
boxes = []
nbox_per_layer = 2
n_layer = 20
h = container_center[2]

for i in range(n_layer):
	nbox_current_layer = 0
	while nbox_current_layer < nbox_per_layer:
		theta = np.random.rand()*np.pi
		T[0, 0] = np.cos(theta)
		T[0, 1] = -np.sin(theta)
		T[1, 0] = np.sin(theta)
		T[1, 1] = np.cos(theta)
		T[0, 3] = container_center[0] + (np.random.rand()-0.5)*0.2
		T[1, 3] = container_center[1] + (np.random.rand()-0.5)*0.05
		T[2, 3] = h        
		box = create_box(T)
		if env.CheckCollision(box):
			env.Remove(box)
		else:
			boxes.append(box)
			nbox_current_layer += 1
	h += 0.011                             #two layers are separated by 1mm
robot = env.GetRobots()[0] # get the first robot
manip = robot.SetActiveManipulator('denso_robotiq_85_gripper')
idle = manip.GetTransform()
ikmodel = orpy.databases.inversekinematics.InverseKinematicsModel(robot,iktype=orpy.IkParameterization.Type.Transform6D)
if not ikmodel.load():
	ikmodel.autogenerate()
lmodel=orpy.databases.linkstatistics.LinkStatisticsModel(robot)
if not lmodel.load():
	lmodel.autogenerate()
lmodel.setRobotResolutions(0.001) # set resolution given smallest object is 0.001m
lmodel.setRobotWeights()
basemanip = orpy.interfaces.BaseManipulation(robot) # create the interface for basic manipulation programs
taskmanip = orpy.interfaces.TaskManipulation(robot) # create the interface for task manipulation programs

def ros_trajectory_from_openrave(robot_name, traj):
	ros_traj = JointTrajectory()
	# Specification groups
	spec = traj.GetConfigurationSpecification()
	try:
		values_group = spec.GetGroupFromName('joint_values {0}'.format(robot_name))
	except orpy.openrave_exception:
		orpy.RaveLogError('Corrupted trajectory. Failed to find group: joint_values')
		return None
	try:
		velocities_group = spec.GetGroupFromName('joint_velocities {0}'.format(robot_name))
	except orpy.openrave_exception:
		orpy.RaveLogError('Corrupted trajectory. Failed to find group: joint_velocities')
		return None	
	try:
		deltatime_group = spec.GetGroupFromName('deltatime')
	except orpy.openrave_exception:
		orpy.RaveLogError('Corrupted trajectory. Failed to find group: deltatime')
		return None
	# Copy waypoints
	time_from_start = 0.04
	for i in range(traj.GetNumWaypoints()):
		waypoint = traj.GetWaypoint(i).tolist()
		deltatime = waypoint[deltatime_group.offset]
	# OpenRAVE trajectory sometimes comes with repeated waypoints. DO NOT append them
		if np.isclose(deltatime, 0) and i > 0:
			continue
    # Append waypoint
		ros_point = JointTrajectoryPoint()
		positions = waypoint[values_group.offset:values_group.offset+values_group.dof]
		velocities = waypoint[velocities_group.offset:velocities_group.offset+velocities_group.dof]
		ros_point.positions = positions[0:6]
		ros_point.velocities = velocities[0:6]
		time_from_start += deltatime
		ros_point.time_from_start = rospy.Duration(time_from_start)
		ros_traj.points.append(ros_point)
	return ros_traj	
def send_traj_to_gazebo(traj):
	ros_traj = ros_trajectory_from_openrave(robot.GetName(),traj)
	traj = Trajectory()
	traj.clear(ros_traj)
	rospy.on_shutdown(traj.stop)
	traj.start()
	traj.wait(15.0)
	print("Exiting - Joint Trajectory Action Test Complete")
	
def main():
	rospy.init_node('denso_client')
	gripper_controller = controller.Robotiq('denso')
	greenbox = boxes[len(boxes)-1]
	T = greenbox.GetTransform()
	T[2,3] += 0.015
	Tgoal = np.dot(T,np.array([[-1,0,0,0],[0,1,0,0],[0,0,-1,0],[0,0,0,1]]))  #grasp along the long edge
	Tnewgoal = np.dot(Tgoal,np.array([[0,-1,0,0],[1,0,0,0],[0,0,1,0],[0,0,0,1]])) # grasp along the short edge
	chosen = Tgoal
	flag = 0
	with robot:
		while True:
			sol = manip.FindIKSolution(Tgoal,orpy.IkFilterOptions.CheckEnvCollisions)
			if sol is not None:
				break
   			else:
				sol  = manip.FindIKSolution(Tnewgoal,orpy.IkFilterOptions.CheckEnvCollisions)
				if sol is not None:
		    			chosen = Tnewgoal
					flag = 1      #flag indicates which edge of the green box the robot pick up (long or short)
					break
  chosen[:3,3] = np.array([0.4, 0.2, 0.500])
  print sol
	sol = np.append(sol,[0])
	traj = directplanner(sol)
	send_traj_to_gazebo(traj)
	taskmanip.CloseFingers()
	robot.WaitForController(0)
	robot.Grab(env.GetKinBody(greenbox.GetName()))
	gripper_controller.close()
	rospy.sleep(1)
	send_traj_to_gazebo(back_to_idle_position())
	gripper_controller.open()
	
if __name__ == "__main__":
	main()
